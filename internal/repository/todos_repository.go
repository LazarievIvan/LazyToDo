package repository

import (
	"LazyToDo/internal/models"
	"context"
	"database/sql"
	"errors"
	"fmt"
	_ "github.com/lib/pq" // blank import to initialize the driver
	"log"
	"strings"
	"time"
)

// TodoRepo has all queries generated by sqlc.
type TodoRepo struct {
	queries *Queries
}

// NewToDoRepo connects to database and constructs TodoRepo object.
func NewToDoRepo() TodoRepo {
	connStr := "postgres://postgres:password@postgres:5432/dev?sslmode=disable"
	db, err := sql.Open("postgres", connStr)
	if err != nil {
		log.Fatal("Unable to connect to the database:", err)
	}
	queries := New(db)
	return TodoRepo{queries: queries}
}

// CreateToDo writes to-do item to DB.
func (r TodoRepo) CreateToDo(item *models.ToDo) (models.ToDo, error) {
	// Check given status, if it's missing - set default ("TO DO") one.
	status := item.Status
	if len(strings.TrimSpace(status)) == 0 {
		item.Status = models.DefaultStatus
	}
	insertedItem, err := r.queries.CreateTodo(context.Background(), CreateTodoParams{
		Description: sql.NullString{String: item.Description, Valid: true},
		Status:      sql.NullString{String: item.Status, Valid: true},
		Created:     sql.NullInt64{Int64: time.Now().Unix(), Valid: true},
		Updated:     sql.NullInt64{Int64: time.Now().Unix(), Valid: true},
	})
	if err != nil {
		return models.ToDo{}, err
	}
	return parseItem(insertedItem), nil
}

// GetToDos retrieves all to-do items from DB.
func (r TodoRepo) GetToDos() ([]models.ToDo, error) {
	todos, err := r.queries.GetTodos(context.Background())
	if err != nil {
		return nil, err
	}

	var items []models.ToDo
	for _, t := range todos {
		items = append(items, parseItem(t))
	}
	return items, nil
}

// GetToDo retrieves single to-do item from DB by given id.
func (r TodoRepo) GetToDo(id int64) (models.ToDo, error) {
	todo, err := r.queries.GetTodo(context.Background(), id)
	if err != nil {
		return models.ToDo{}, nil
	}
	return parseItem(todo), nil
}

// UpdateToDo updates single to-do item in DB with new information by given id.
func (r TodoRepo) UpdateToDo(updatedItem *models.ToDo, id int64) (models.ToDo, error) {
	// Get old item, that's being updated.
	oldItem, err := r.GetToDo(id)
	if err != nil {
		return models.ToDo{}, errors.New(fmt.Sprintf("Unable to find item with id %d. Error: %v", id, err))
	}

	// If new description is missing, set it to old one, so it won't be updated.
	if len(strings.TrimSpace(updatedItem.Description)) == 0 {
		updatedItem.Description = oldItem.Description
	}
	// If new status is missing, set it to old one, so it won't be updated.
	if len(strings.TrimSpace(updatedItem.Status)) == 0 {
		updatedItem.Status = oldItem.Status
	}

	todo, err := r.queries.UpdateTodo(context.Background(), UpdateTodoParams{
		ID:          id,
		Description: sql.NullString{String: updatedItem.Description, Valid: true},
		Status:      sql.NullString{String: updatedItem.Status, Valid: true},
		Updated:     sql.NullInt64{Int64: time.Now().Unix(), Valid: true},
	})
	if err != nil {
		return models.ToDo{}, err
	}
	return parseItem(todo), nil
}

// DeleteToDo deletes single to-do item from DB by given id.
func (r TodoRepo) DeleteToDo(id int64) error {
	err := r.queries.DeleteTodo(context.Background(), id)
	if err != nil {
		return err
	}
	return nil
}

func parseItem(item Todo) models.ToDo {
	var todo models.ToDo
	todo.ID = item.ID
	todo.Description = item.Description.String
	todo.Status = item.Status.String
	todo.Created = item.Created.Int64
	todo.Updated = item.Updated.Int64
	return todo
}
