package repository

import (
	"LazyToDo/internal/models"
	"context"
	"database/sql"
	"fmt"
	_ "github.com/lib/pq" // blank import to initialize the driver
	"log"
	"net/http"
	"strings"
	"time"
)

// TodoRepo has all queries generated by sqlc.
type TodoRepo struct {
	queries *Queries
}

// NewToDoRepo connects to database and constructs TodoRepo object.
func NewToDoRepo() TodoRepo {
	connStr := "postgres://postgres:password@postgres:5432/dev?sslmode=disable"
	db, err := sql.Open("postgres", connStr)
	if err != nil {
		log.Fatal("Unable to connect to the database:", err)
	}
	queries := New(db)
	return TodoRepo{queries: queries}
}

// GetToDos retrieves all to-dos within given parameters.
// If no parameters passed - all to-dos are retrieved.
// Supported: sorting by id/dates; filtering by status.
func (r TodoRepo) GetToDos(params *models.ParamsBag) ([]models.ToDo, error) {
	// Sort by ID ASC by default.
	if len(params.Sort.Field) == 0 {
		params.Sort.Field = "id"
		params.Sort.ASC = true
	}
	ascending := "ASC"
	if params.Sort.ASC == false {
		ascending = "DESC"
	}
	// Build base query.
	query := "SELECT * FROM todos"
	// Add filters if any.
	if len(params.Filter.Filters) > 0 {
		query = fmt.Sprintf("%s WHERE", query)
		for i, filter := range params.Filter.Filters {
			query = fmt.Sprintf("%s %s = '%s'", query, filter.Field, filter.Value)
			if i < len(params.Filter.Filters)-1 {
				query += " AND "
			}
		}
	}
	// Apply sorting.
	query = fmt.Sprintf("%s ORDER BY %s %s", query, params.Sort.Field, ascending)
	// Apply pagination.
	if params.Paging.Limit > 0 {
		query = fmt.Sprintf("%s LIMIT %d", query, params.Paging.Limit)
		if params.Paging.Offset > 0 {
			query = fmt.Sprintf("%s OFFSET %d", query, params.Paging.Offset)
		}
	}
	// Execute query.
	rows, err := r.queries.db.QueryContext(context.Background(), query)
	if err != nil {
		return nil, err
	}
	defer func(rows *sql.Rows) {
		err := rows.Close()
		if err != nil {
			fmt.Println(err)
		}
	}(rows)
	// Parse response.
	var items []models.ToDo
	for rows.Next() {
		var i models.ToDo
		if err := rows.Scan(
			&i.ID,
			&i.Description,
			&i.Status,
			&i.Created,
			&i.Updated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

// CreateToDo writes to-do item to DB.
func (r TodoRepo) CreateToDo(item *models.ToDo) (models.ToDo, error) {
	// Check given status, if it's missing - set default ("TO DO") one.
	status := item.Status
	if len(strings.TrimSpace(status)) == 0 {
		item.Status = models.DefaultStatus
	}
	insertedItem, err := r.queries.CreateTodo(context.Background(), CreateTodoParams{
		Description: sql.NullString{String: item.Description, Valid: true},
		Status:      sql.NullString{String: item.Status, Valid: true},
		Created:     sql.NullInt64{Int64: time.Now().Unix(), Valid: true},
		Updated:     sql.NullInt64{Int64: time.Now().Unix(), Valid: true},
	})
	if err != nil {
		return models.ToDo{}, models.NewDBError("Unable to create item with id", http.StatusInternalServerError, err)
	}
	return parseItem(insertedItem), nil
}

// GetToDo retrieves single to-do item from DB by given id.
func (r TodoRepo) GetToDo(id int64) (models.ToDo, error) {
	todo, err := r.queries.GetTodo(context.Background(), id)
	if err != nil {
		return models.ToDo{}, models.NewDBError(fmt.Sprintf("Unable to find item with id %d", id), http.StatusNotFound, err)
	}
	return parseItem(todo), nil
}

// UpdateToDo updates single to-do item in DB with new information by given id.
func (r TodoRepo) UpdateToDo(updatedItem *models.ToDo, id int64) (models.ToDo, error) {
	// Get old item, that's being updated.
	oldItem, err := r.GetToDo(id)
	if err != nil {
		return models.ToDo{}, models.NewDBError(fmt.Sprintf("Unable to find item with id %d", id), http.StatusNotFound, err)
	}

	// If new description is missing, set it to old one, so it won't be updated.
	if len(strings.TrimSpace(updatedItem.Description)) == 0 {
		updatedItem.Description = oldItem.Description
	}
	// If new status is missing, set it to old one, so it won't be updated.
	if len(strings.TrimSpace(updatedItem.Status)) == 0 {
		updatedItem.Status = oldItem.Status
	}

	todo, err := r.queries.UpdateTodo(context.Background(), UpdateTodoParams{
		ID:          id,
		Description: sql.NullString{String: updatedItem.Description, Valid: true},
		Status:      sql.NullString{String: updatedItem.Status, Valid: true},
		Updated:     sql.NullInt64{Int64: time.Now().Unix(), Valid: true},
	})
	if err != nil {
		return models.ToDo{}, models.NewDBError(fmt.Sprintf("Unable to update item with id %d", id), http.StatusInternalServerError, err)
	}
	return parseItem(todo), nil
}

// DeleteToDo deletes single to-do item from DB by given id.
func (r TodoRepo) DeleteToDo(id int64) error {
	_, err := r.queries.GetTodo(context.Background(), id)
	if err != nil {
		return models.NewDBError(fmt.Sprintf("Unable to find item with id %d", id), http.StatusNotFound, err)
	}
	err = r.queries.DeleteTodo(context.Background(), id)
	if err != nil {
		return models.NewDBError(fmt.Sprintf("Unable to delete item with id %d", id), http.StatusInternalServerError, err)
	}
	return nil
}

func parseItem(item Todo) models.ToDo {
	var todo models.ToDo
	todo.ID = item.ID
	todo.Description = item.Description.String
	todo.Status = item.Status.String
	todo.Created = item.Created.Int64
	todo.Updated = item.Updated.Int64
	return todo
}
